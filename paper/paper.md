---
title: 'bam2fasta: Package to convert bam files to fasta per single cell barcode'
authors:
- affiliation: 1
  name: Venkata Naga Pranathi Vemuri
  orcid: 0000-0002-5748-9594
- affiliation: 1
  name: Olga Borisovna Botvinnik
  orcid: 0000-0003-4412-7970

date: "31 December 2019"
output:
  html_document:
    df_print: paged
  pdf_document: default
  word_document: default
bibliography: paper.bib
tags:
- single cell
- bam
- 10x genomics
- fasta
- barcode
affiliations:
- index: 1
  name: Data Sciences Platform, Chan Zuckerberg Biohub, San Francisco, CA
---

# Summary

Next Gen Sequencing has made leaps over the last decades in the amount of data it can sequence parallely.
With the help of dropseq microfluidics allowing cell barcodes with new unique molecule types to be sequenced simultaneously with many other cell barcodes of a cell type. 
So, we end up with a lot of data to process in the bam file with no filter on the barcodes.
There are barcodes incorrectly tagged due to a chemical reaction or not enough quality that enter in the bam file.
Hence we need a tool to filter these bam files by barcodes and convert them to fasta files for further data exploration. In this paper we present a technique that converts a bam file to fasta file per cell barcode given different conditions like unique molecular identifier (UMIs) accepted per barcode and valid barcodes list if exists.

The `.bam` file generated by the Drop-seq [@doi:10.1016/j.cell.2015.05.002] pipeline for the different primates in this study are in the order of 6-12 GB. 
The Drop-seq `.bam` files so obtained can attribute to few limitations as discussed below.
Firstly, loading them in memory all at once would require a lot of RAM depending on how the program will allocate memory for different data typed tags in the `.bam` file. 
Secondly, if Drop-seq data is not accompanied by a barcodes file to filter the `.bam` file on, it would mean we would have to recursively go through the alignments in the bam file and deduce alignments with higher quality and combine sequences with already exisiting barcodes. 
This would need a look up dictionary to be updated as it loops through the alignments in the `.bam` file and would search the look up dictionary as it updates the barcodes. 
In conclusion, this is a very memory intensive process that seemed to fail on even machines with 2TB RAM.


Hence we propose a method that could work on a computer with lesser RAM and not cause computer hangups. 
We released an open source pypi package for the same [@url:https://pypi.org/project/bam2fasta/].
The package contains solution for the above discussed problem by sharding the `.bam` file into chunks of smaller `.bam` files and stores them in the machine's temporary folder, e.g. `/tmp`.
The chunk size of the `.bam` file is a tunable parameter that can be accessed with `--line_count`; by default it is 1500 alignment lines.
This process is done serially by iterating through the alignments in the `.bam` file, using `pysam`, a Python wrapper around samtools [@doi:10.1093/bioinformatics/btp352].
Now we employ a MapReduce [@doi:10.1145/1327452.1327492] approach to the temporary `.bam` files to obtain all the reads per cell barcode in a `.fasta` file.
In the "Map" step, we distribute the computation i.e parsing the barcode, determining the quality of the read, and if alignment is not duplicated, in parallel across multiple processes on the temporary shards of `.bam` files. 
These bam shards create temporary `.fasta` files that contain for each read: the cell barcode, unique molecular identifier (UMI), and the aligned sequence.
There might be a cell barcode that would be present in different chunks of these sharded `.bam` files.
As a result we would have multiple temporary `.fasta` files for the same barcodes.
We implemented a method to find the unique barcodes based on these temporary `.fasta` file names and then assigning each of the unique barcodes all the temporary barcode `.fasta` files created by different `.bam` shards in a dictionary. 
In the "Reduce" step, we concatenate of strings of temporary `.fasta` file names, hence its memory consumption is less than it would be if appending to a list. 
These temporary `.fasta` files are then combined to one `.fasta` file per barcode by concatenating all the sequences obtained from different `.fasta` files. 
The concatenation of all sequences for each of the unique barcodes is also then parallelized to use multiple processes.
For each of the cell barcodes, there is an option to obtain valid cell barcodes, based on the UMI count per cell barcode.
For our datasets we have set the minimum number of UMIs per cell barcode to 1000, a common threshold. 
The minimum number of UMIs per cell barcode can be customized with the flag `--min-umi-per-barcode`.
The computational resources and time taken for processing is as shown in Table [@tbl:bam2fasta-runtime-ram].


|  Primate  | BAM file size(GB)  | Time(hrs)| RAM(GB) | Processes |
| :-------- | :------------------| :--------| :-------| :---------|
| Human     | 12                 | 7        | 16      | 32        |
| Orangutan | 9                  | 4        | 16      | 32        |
| Chimp     | 9                  | 4        | 16      | 32        |

Table: Human primate species bam file here is from a brain organoid for human {#tbl:bam2fasta-runtime-ram}

This method primarily gives us time performance improvement. 
It reduces time from days or just process running out of memory to hours. 
Depending on the size of `.bam` file and resources of the cluster/computer it can be further reduced. 

# Implementation

## Workflow

bam2fasta builds on two major algorithms that are already implemented in other software packages. The first is the pysam


## Confidence values

## Other features


# Installation

The bam2fasta package is programmed in python, and is available in the bioconda and pypi.
Documentation can be found at https://github.com/czbiohub/bam2fasta/.

# Figures

# Acknowledgements


# References
